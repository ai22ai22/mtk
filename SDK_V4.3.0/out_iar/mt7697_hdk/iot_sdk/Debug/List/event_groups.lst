###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:21
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\kernel\rtos\FreeRTOS\Source\event_groups.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW6624.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\kernel\rtos\FreeRTOS\Source\event_groups.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\event_groups.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\event_groups.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\kernel\rtos\FreeRTOS\Source\event_groups.c
      1          /*
      2              FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     12          
     13          	***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18          	***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40          	the FAQ page "My application does not run, what could be wrong?".  Have you
     41          	defined configASSERT()?
     42          
     43          	http://www.FreeRTOS.org/support - In return for receiving this top quality
     44          	embedded software for free we request you assist our global community by
     45          	participating in the support forum.
     46          
     47          	http://www.FreeRTOS.org/training - Investing in training allows your team to
     48          	be as productive as possible as early as possible.  Now you can receive
     49          	FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50          	Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          
     73          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     74          all the API functions to use the MPU wrappers.  That should only be done when
     75          task.h is included from an application file. */
     76          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     77          
     78          /* FreeRTOS includes. */
     79          #include "FreeRTOS.h"
     80          #include "task.h"
     81          #include "timers.h"
     82          #include "event_groups.h"
     83          
     84          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     85          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     86          header files above, but not in this file, in order to generate the correct
     87          privileged Vs unprivileged linkage and placement. */
     88          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     89          
     90          #if ( INCLUDE_xEventGroupSetBitFromISR == 1 ) && ( configUSE_TIMERS == 0 )
     91          	#error configUSE_TIMERS must be set to 1 to make the xEventGroupSetBitFromISR() function available.
     92          #endif
     93          
     94          #if ( INCLUDE_xEventGroupSetBitFromISR == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 0 )
     95          	#error INCLUDE_xTimerPendFunctionCall must also be set to one to make the xEventGroupSetBitFromISR() function available.
     96          #endif
     97          
     98          /* The following bit fields convey control information in a task's event list
     99          item value.  It is important they don't clash with the
    100          taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
    101          #if configUSE_16_BIT_TICKS == 1
    102          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
    103          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
    104          	#define eventWAIT_FOR_ALL_BITS			0x0400U
    105          	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
    106          #else
    107          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
    108          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
    109          	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
    110          	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
    111          #endif
    112          
    113          typedef struct xEventGroupDefinition
    114          {
    115          	EventBits_t uxEventBits;
    116          	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
    117          
    118          	#if( configUSE_TRACE_FACILITY == 1 )
    119          		UBaseType_t uxEventGroupNumber;
    120          	#endif
    121          
    122          } EventGroup_t;
    123          
    124          /*-----------------------------------------------------------*/
    125          
    126          /*
    127           * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
    128           * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
    129           * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
    130           * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
    131           * wait condition is met if any of the bits set in uxBitsToWait for are also set
    132           * in uxCurrentEventBits.
    133           */
    134          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );
    135          
    136          /*-----------------------------------------------------------*/
    137          
    138          EventGroupHandle_t xEventGroupCreate( void )
    139          {
    140          EventGroup_t *pxEventBits;
    141          
    142          	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    143          	if( pxEventBits != NULL )
    144          	{
    145          		pxEventBits->uxEventBits = 0;
    146          		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    147          		traceEVENT_GROUP_CREATE( pxEventBits );
    148          	}
    149          	else
    150          	{
    151          		traceEVENT_GROUP_CREATE_FAILED();
    152          	}
    153          
    154          	return ( EventGroupHandle_t ) pxEventBits;
    155          }
    156          /*-----------------------------------------------------------*/
    157          
    158          EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
    159          {
    160          EventBits_t uxOriginalBitValue, uxReturn;
    161          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    162          BaseType_t xAlreadyYielded;
    163          BaseType_t xTimeoutOccurred = pdFALSE;
    164          
    165          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    166          	configASSERT( uxBitsToWaitFor != 0 );
    167          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    168          	{
    169          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    170          	}
    171          	#endif
    172          
    173          	vTaskSuspendAll();
    174          	{
    175          		uxOriginalBitValue = pxEventBits->uxEventBits;
    176          
    177          		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    178          
    179          		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    180          		{
    181          			/* All the rendezvous bits are now set - no need to block. */
    182          			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    183          
    184          			/* Rendezvous always clear the bits.  They will have been cleared
    185          			already unless this is the only task in the rendezvous. */
    186          			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    187          
    188          			xTicksToWait = 0;
    189          		}
    190          		else
    191          		{
    192          			if( xTicksToWait != ( TickType_t ) 0 )
    193          			{
    194          				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
    195          
    196          				/* Store the bits that the calling task is waiting for in the
    197          				task's event list item so the kernel knows when a match is
    198          				found.  Then enter the blocked state. */
    199          				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    200          
    201          				/* This assignment is obsolete as uxReturn will get set after
    202          				the task unblocks, but some compilers mistakenly generate a
    203          				warning about uxReturn being returned without being set if the
    204          				assignment is omitted. */
    205          				uxReturn = 0;
    206          			}
    207          			else
    208          			{
    209          				/* The rendezvous bits were not set, but no block time was
    210          				specified - just return the current event bit value. */
    211          				uxReturn = pxEventBits->uxEventBits;
    212          			}
    213          		}
    214          	}
    215          	xAlreadyYielded = xTaskResumeAll();
    216          
    217          	if( xTicksToWait != ( TickType_t ) 0 )
    218          	{
    219          		if( xAlreadyYielded == pdFALSE )
    220          		{
    221          			portYIELD_WITHIN_API();
    222          		}
    223          		else
    224          		{
    225          			mtCOVERAGE_TEST_MARKER();
    226          		}
    227          
    228          		/* The task blocked to wait for its required bits to be set - at this
    229          		point either the required bits were set or the block time expired.  If
    230          		the required bits were set they will have been stored in the task's
    231          		event list item, and they should now be retrieved then cleared. */
    232          		uxReturn = uxTaskResetEventItemValue();
    233          
    234          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    235          		{
    236          			/* The task timed out, just return the current event bit value. */
    237          			taskENTER_CRITICAL();
    238          			{
    239          				uxReturn = pxEventBits->uxEventBits;
    240          
    241          				/* Although the task got here because it timed out before the
    242          				bits it was waiting for were set, it is possible that since it
    243          				unblocked another task has set the bits.  If this is the case
    244          				then it needs to clear the bits before exiting. */
    245          				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    246          				{
    247          					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    248          				}
    249          				else
    250          				{
    251          					mtCOVERAGE_TEST_MARKER();
    252          				}
    253          			}
    254          			taskEXIT_CRITICAL();
    255          
    256          			xTimeoutOccurred = pdTRUE;
    257          		}
    258          		else
    259          		{
    260          			/* The task unblocked because the bits were set. */
    261          		}
    262          
    263          		/* Control bits might be set as the task had blocked should not be
    264          		returned. */
    265          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    266          	}
    267          
    268          	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
    269          
    270          	return uxReturn;
    271          }
    272          /*-----------------------------------------------------------*/
    273          
    274          EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
    275          {
    276          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    277          EventBits_t uxReturn, uxControlBits = 0;
    278          BaseType_t xWaitConditionMet, xAlreadyYielded;
    279          BaseType_t xTimeoutOccurred = pdFALSE;
    280          
    281          	/* Check the user is not attempting to wait on the bits used by the kernel
    282          	itself, and that at least one bit is being requested. */
    283          	configASSERT( xEventGroup );
    284          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    285          	configASSERT( uxBitsToWaitFor != 0 );
    286          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    287          	{
    288          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    289          	}
    290          	#endif
    291          
    292          	vTaskSuspendAll();
    293          	{
    294          		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    295          
    296          		/* Check to see if the wait condition is already met or not. */
    297          		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    298          
    299          		if( xWaitConditionMet != pdFALSE )
    300          		{
    301          			/* The wait condition has already been met so there is no need to
    302          			block. */
    303          			uxReturn = uxCurrentEventBits;
    304          			xTicksToWait = ( TickType_t ) 0;
    305          
    306          			/* Clear the wait bits if requested to do so. */
    307          			if( xClearOnExit != pdFALSE )
    308          			{
    309          				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    310          			}
    311          			else
    312          			{
    313          				mtCOVERAGE_TEST_MARKER();
    314          			}
    315          		}
    316          		else if( xTicksToWait == ( TickType_t ) 0 )
    317          		{
    318          			/* The wait condition has not been met, but no block time was
    319          			specified, so just return the current value. */
    320          			uxReturn = uxCurrentEventBits;
    321          		}
    322          		else
    323          		{
    324          			/* The task is going to block to wait for its required bits to be
    325          			set.  uxControlBits are used to remember the specified behaviour of
    326          			this call to xEventGroupWaitBits() - for use when the event bits
    327          			unblock the task. */
    328          			if( xClearOnExit != pdFALSE )
    329          			{
    330          				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    331          			}
    332          			else
    333          			{
    334          				mtCOVERAGE_TEST_MARKER();
    335          			}
    336          
    337          			if( xWaitForAllBits != pdFALSE )
    338          			{
    339          				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    340          			}
    341          			else
    342          			{
    343          				mtCOVERAGE_TEST_MARKER();
    344          			}
    345          
    346          			/* Store the bits that the calling task is waiting for in the
    347          			task's event list item so the kernel knows when a match is
    348          			found.  Then enter the blocked state. */
    349          			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    350          
    351          			/* This is obsolete as it will get set after the task unblocks, but
    352          			some compilers mistakenly generate a warning about the variable
    353          			being returned without being set if it is not done. */
    354          			uxReturn = 0;
    355          
    356          			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
    357          		}
    358          	}
    359          	xAlreadyYielded = xTaskResumeAll();
    360          
    361          	if( xTicksToWait != ( TickType_t ) 0 )
    362          	{
    363          		if( xAlreadyYielded == pdFALSE )
    364          		{
    365          			portYIELD_WITHIN_API();
    366          		}
    367          		else
    368          		{
    369          			mtCOVERAGE_TEST_MARKER();
    370          		}
    371          
    372          		/* The task blocked to wait for its required bits to be set - at this
    373          		point either the required bits were set or the block time expired.  If
    374          		the required bits were set they will have been stored in the task's
    375          		event list item, and they should now be retrieved then cleared. */
    376          		uxReturn = uxTaskResetEventItemValue();
    377          
    378          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    379          		{
    380          			taskENTER_CRITICAL();
    381          			{
    382          				/* The task timed out, just return the current event bit value. */
    383          				uxReturn = pxEventBits->uxEventBits;
    384          
    385          				/* It is possible that the event bits were updated between this
    386          				task leaving the Blocked state and running again. */
    387          				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    388          				{
    389          					if( xClearOnExit != pdFALSE )
    390          					{
    391          						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    392          					}
    393          					else
    394          					{
    395          						mtCOVERAGE_TEST_MARKER();
    396          					}
    397          				}
    398          				else
    399          				{
    400          					mtCOVERAGE_TEST_MARKER();
    401          				}
    402          			}
    403          			taskEXIT_CRITICAL();
    404          
    405          			/* Prevent compiler warnings when trace macros are not used. */
    406          			xTimeoutOccurred = pdFALSE;
    407          		}
    408          		else
    409          		{
    410          			/* The task unblocked because the bits were set. */
    411          		}
    412          
    413          		/* The task blocked so control bits may have been set. */
    414          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    415          	}
    416          	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
    417          
    418          	return uxReturn;
    419          }
    420          /*-----------------------------------------------------------*/
    421          
    422          EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    423          {
    424          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    425          EventBits_t uxReturn;
    426          
    427          	/* Check the user is not attempting to clear the bits used by the kernel
    428          	itself. */
    429          	configASSERT( xEventGroup );
    430          	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    431          
    432          	taskENTER_CRITICAL();
    433          	{
    434          		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
    435          
    436          		/* The value returned is the event group value prior to the bits being
    437          		cleared. */
    438          		uxReturn = pxEventBits->uxEventBits;
    439          
    440          		/* Clear the bits. */
    441          		pxEventBits->uxEventBits &= ~uxBitsToClear;
    442          	}
    443          	taskEXIT_CRITICAL();
    444          
    445          	return uxReturn;
    446          }
    447          /*-----------------------------------------------------------*/
    448          
    449          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    450          
    451          	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    452          	{
    453          		BaseType_t xReturn;
    454          
    455          		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
    456          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
    457          
    458          		return xReturn;
    459          	}
    460          
    461          #endif
    462          /*-----------------------------------------------------------*/
    463          
    464          EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
    465          {
    466          UBaseType_t uxSavedInterruptStatus;
    467          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    468          EventBits_t uxReturn;
    469          
    470          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    471          	{
    472          		uxReturn = pxEventBits->uxEventBits;
    473          	}
    474          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    475          
    476          	return uxReturn;
    477          }
    478          /*-----------------------------------------------------------*/
    479          
    480          EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
    481          {
    482          ListItem_t *pxListItem, *pxNext;
    483          ListItem_t const *pxListEnd;
    484          List_t *pxList;
    485          EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    486          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    487          BaseType_t xMatchFound = pdFALSE;
    488          
    489          	/* Check the user is not attempting to set the bits used by the kernel
    490          	itself. */
    491          	configASSERT( xEventGroup );
    492          	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    493          
    494          	pxList = &( pxEventBits->xTasksWaitingForBits );
    495          	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    496          	vTaskSuspendAll();
    497          	{
    498          		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
    499          
    500          		pxListItem = listGET_HEAD_ENTRY( pxList );
    501          
    502          		/* Set the bits. */
    503          		pxEventBits->uxEventBits |= uxBitsToSet;
    504          
    505          		/* See if the new bit value should unblock any tasks. */
    506          		while( pxListItem != pxListEnd )
    507          		{
    508          			pxNext = listGET_NEXT( pxListItem );
    509          			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    510          			xMatchFound = pdFALSE;
    511          
    512          			/* Split the bits waited for from the control bits. */
    513          			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    514          			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    515          
    516          			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    517          			{
    518          				/* Just looking for single bit being set. */
    519          				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    520          				{
    521          					xMatchFound = pdTRUE;
    522          				}
    523          				else
    524          				{
    525          					mtCOVERAGE_TEST_MARKER();
    526          				}
    527          			}
    528          			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    529          			{
    530          				/* All bits are set. */
    531          				xMatchFound = pdTRUE;
    532          			}
    533          			else
    534          			{
    535          				/* Need all bits to be set, but not all the bits were set. */
    536          			}
    537          
    538          			if( xMatchFound != pdFALSE )
    539          			{
    540          				/* The bits match.  Should the bits be cleared on exit? */
    541          				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    542          				{
    543          					uxBitsToClear |= uxBitsWaitedFor;
    544          				}
    545          				else
    546          				{
    547          					mtCOVERAGE_TEST_MARKER();
    548          				}
    549          
    550          				/* Store the actual event flag value in the task's event list
    551          				item before removing the task from the event list.  The
    552          				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
    553          				that is was unblocked due to its required bits matching, rather
    554          				than because it timed out. */
    555          				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    556          			}
    557          
    558          			/* Move onto the next list item.  Note pxListItem->pxNext is not
    559          			used here as the list item may have been removed from the event list
    560          			and inserted into the ready/pending reading list. */
    561          			pxListItem = pxNext;
    562          		}
    563          
    564          		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
    565          		bit was set in the control word. */
    566          		pxEventBits->uxEventBits &= ~uxBitsToClear;
    567          	}
    568          	( void ) xTaskResumeAll();
    569          
    570          	return pxEventBits->uxEventBits;
    571          }
    572          /*-----------------------------------------------------------*/
    573          
    574          void vEventGroupDelete( EventGroupHandle_t xEventGroup )
    575          {
    576          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    577          const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    578          
    579          	vTaskSuspendAll();
    580          	{
    581          		traceEVENT_GROUP_DELETE( xEventGroup );
    582          
    583          		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    584          		{
    585          			/* Unblock the task, returning 0 as the event list is being deleted
    586          			and	cannot therefore have any bits set. */
    587          			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
    588          			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    589          		}
    590          
    591          		vPortFree( pxEventBits );
    592          	}
    593          	( void ) xTaskResumeAll();
    594          }
    595          /*-----------------------------------------------------------*/
    596          
    597          /* For internal use only - execute a 'set bits' command that was pended from
    598          an interrupt. */
    599          void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
    600          {
    601          	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    602          }
    603          /*-----------------------------------------------------------*/
    604          
    605          /* For internal use only - execute a 'clear bits' command that was pended from
    606          an interrupt. */
    607          void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
    608          {
    609          	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    610          }
    611          /*-----------------------------------------------------------*/
    612          
    613          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
    614          {
    615          BaseType_t xWaitConditionMet = pdFALSE;
    616          
    617          	if( xWaitForAllBits == pdFALSE )
    618          	{
    619          		/* Task only has to wait for one bit within uxBitsToWaitFor to be
    620          		set.  Is one already set? */
    621          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    622          		{
    623          			xWaitConditionMet = pdTRUE;
    624          		}
    625          		else
    626          		{
    627          			mtCOVERAGE_TEST_MARKER();
    628          		}
    629          	}
    630          	else
    631          	{
    632          		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
    633          		Are they set already? */
    634          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    635          		{
    636          			xWaitConditionMet = pdTRUE;
    637          		}
    638          		else
    639          		{
    640          			mtCOVERAGE_TEST_MARKER();
    641          		}
    642          	}
    643          
    644          	return xWaitConditionMet;
    645          }
    646          /*-----------------------------------------------------------*/
    647          
    648          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    649          
    650          	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
    651          	{
    652          	BaseType_t xReturn;
    653          
    654          		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
    655          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
    656          
    657          		return xReturn;
    658          	}
    659          
    660          #endif
    661          /*-----------------------------------------------------------*/
    662          
    663          #if (configUSE_TRACE_FACILITY == 1)
    664          
    665          	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
    666          	{
    667          	UBaseType_t xReturn;
    668          	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    669          
    670          		if( xEventGroup == NULL )
    671          		{
    672          			xReturn = 0;
    673          		}
    674          		else
    675          		{
    676          			xReturn = pxEventBits->uxEventGroupNumber;
    677          		}
    678          
    679          		return xReturn;
    680          	}
    681          
    682          #endif
    683          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   prvTestWaitCondition
       0   uxEventGroupGetNumber
       0   vEventGroupClearBitsCallback
         0   -> xEventGroupClearBits
       8   vEventGroupDelete
         8   -> platform_assert
         8   -> vPortFree
         8   -> vTaskSuspendAll
         8   -> xTaskRemoveFromUnorderedEventList
         0   -> xTaskResumeAll
       0   vEventGroupSetBitsCallback
         0   -> xEventGroupSetBits
      24   xEventGroupClearBits
        24   -> platform_assert
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
       8   xEventGroupCreate
         8   -> pvPortMalloc
         8   -> vListInitialise
       0   xEventGroupGetBitsFromISR
      24   xEventGroupSetBits
        24   -> platform_assert
        24   -> vTaskSuspendAll
        24   -> xTaskRemoveFromUnorderedEventList
        24   -> xTaskResumeAll
      32   xEventGroupSync
        32   -> platform_assert
        32   -> uxTaskResetEventItemValue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskPlaceOnUnorderedEventList
        32   -> vTaskSuspendAll
        32   -> xEventGroupSetBits
        32   -> xTaskGetSchedulerState
        32   -> xTaskResumeAll
      40   xEventGroupWaitBits
        40   -> platform_assert
        40   -> prvTestWaitCondition
        40   -> uxTaskResetEventItemValue
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vTaskPlaceOnUnorderedEventList
        40   -> vTaskSuspendAll
        40   -> xTaskGetSchedulerState
        40   -> xTaskResumeAll


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
      60  ?_0
      76  ?_1
      24  ?_2
      88  ?_3
      12  ?_4
      56  ?_5
      56  ?_6
      96  ?_7
      30  prvTestWaitCondition
      12  uxEventGroupGetNumber
       2  vEventGroupClearBitsCallback
      66  vEventGroupDelete
       2  vEventGroupSetBitsCallback
      70  xEventGroupClearBits
      26  xEventGroupCreate
      26  xEventGroupGetBitsFromISR
     152  xEventGroupSetBits
     224  xEventGroupSync
     286  xEventGroupWaitBits

 
 1 368 bytes in section .text
 
 1 368 bytes of CODE memory

Errors: none
Warnings: none
