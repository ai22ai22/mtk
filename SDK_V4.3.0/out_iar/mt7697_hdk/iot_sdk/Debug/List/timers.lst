###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:43
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\kernel\rtos\FreeRTOS\Source\timers.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EWBC68.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\kernel\rtos\FreeRTOS\Source\timers.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\timers.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\timers.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\kernel\rtos\FreeRTOS\Source\timers.c
      1          /*
      2              FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     12          
     13          	***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18          	***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40          	the FAQ page "My application does not run, what could be wrong?".  Have you
     41          	defined configASSERT()?
     42          
     43          	http://www.FreeRTOS.org/support - In return for receiving this top quality
     44          	embedded software for free we request you assist our global community by
     45          	participating in the support forum.
     46          
     47          	http://www.FreeRTOS.org/training - Investing in training allows your team to
     48          	be as productive as possible as early as possible.  Now you can receive
     49          	FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50          	Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          
     73          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     74          all the API functions to use the MPU wrappers.  That should only be done when
     75          task.h is included from an application file. */
     76          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     77          
     78          #include "FreeRTOS.h"
     79          #include "task.h"
     80          #include "queue.h"
     81          #include "timers.h"
     82          
     83          #if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
     84          	#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.
     85          #endif
     86          
     87          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     88          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     89          header files above, but not in this file, in order to generate the correct
     90          privileged Vs unprivileged linkage and placement. */
     91          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     92          
     93          
     94          /* This entire source file will be skipped if the application is not configured
     95          to include software timer functionality.  This #if is closed at the very bottom
     96          of this file.  If you want to include software timer functionality then ensure
     97          configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
     98          #if ( configUSE_TIMERS == 1 )
     99          
    100          /* Misc definitions. */
    101          #define tmrNO_DELAY		( TickType_t ) 0U
    102          
    103          /* The definition of the timers themselves. */
    104          typedef struct tmrTimerControl
    105          {
    106          	const char				*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    107          	ListItem_t				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
    108          	TickType_t				xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
    109          	UBaseType_t				uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. */
    110          	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
    111          	TimerCallbackFunction_t	pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
    112          	#if( configUSE_TRACE_FACILITY == 1 )
    113          		UBaseType_t			uxTimerNumber;		/*<< An ID assigned by trace tools such as FreeRTOS+Trace */
    114          	#endif
    115          } xTIMER;
    116          
    117          /* The old xTIMER name is maintained above then typedefed to the new Timer_t
    118          name below to enable the use of older kernel aware debuggers. */
    119          typedef xTIMER Timer_t;
    120          
    121          /* The definition of messages that can be sent and received on the timer queue.
    122          Two types of message can be queued - messages that manipulate a software timer,
    123          and messages that request the execution of a non-timer related callback.  The
    124          two message types are defined in two separate structures, xTimerParametersType
    125          and xCallbackParametersType respectively. */
    126          typedef struct tmrTimerParameters
    127          {
    128          	TickType_t			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
    129          	Timer_t *			pxTimer;			/*<< The timer to which the command will be applied. */
    130          } TimerParameter_t;
    131          
    132          
    133          typedef struct tmrCallbackParameters
    134          {
    135          	PendedFunction_t	pxCallbackFunction;	/* << The callback function to execute. */
    136          	void *pvParameter1;						/* << The value that will be used as the callback functions first parameter. */
    137          	uint32_t ulParameter2;					/* << The value that will be used as the callback functions second parameter. */
    138          } CallbackParameters_t;
    139          
    140          /* The structure that contains the two message types, along with an identifier
    141          that is used to determine which message type is valid. */
    142          typedef struct tmrTimerQueueMessage
    143          {
    144          	BaseType_t			xMessageID;			/*<< The command being sent to the timer service task. */
    145          	union
    146          	{
    147          		TimerParameter_t xTimerParameters;
    148          
    149          		/* Don't include xCallbackParameters if it is not going to be used as
    150          		it makes the structure (and therefore the timer queue) larger. */
    151          		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
    152          			CallbackParameters_t xCallbackParameters;
    153          		#endif /* INCLUDE_xTimerPendFunctionCall */
    154          	} u;
    155          } DaemonTaskMessage_t;
    156          
    157          /*lint -e956 A manual analysis and inspection has been used to determine which
    158          static variables must be declared volatile. */
    159          
    160          /* The list in which active timers are stored.  Timers are referenced in expire
    161          time order, with the nearest expiry time at the front of the list.  Only the
    162          timer service task is allowed to access these lists. */
    163          PRIVILEGED_DATA static List_t xActiveTimerList1;
    164          PRIVILEGED_DATA static List_t xActiveTimerList2;
    165          PRIVILEGED_DATA static List_t *pxCurrentTimerList;
    166          PRIVILEGED_DATA static List_t *pxOverflowTimerList;
    167          
    168          /* A queue that is used to send commands to the timer service task. */
    169          PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
    170          
    171          #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    172          
    173          	PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
    174          
    175          #endif
    176          
    177          /*lint +e956 */
    178          
    179          /*-----------------------------------------------------------*/
    180          
    181          /*
    182           * Initialise the infrastructure used by the timer service task if it has not
    183           * been initialised already.
    184           */
    185          static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
    186          
    187          /*
    188           * The timer service task (daemon).  Timer functionality is controlled by this
    189           * task.  Other tasks communicate with the timer service task using the
    190           * xTimerQueue queue.
    191           */
    192          static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
    193          
    194          /*
    195           * Called by the timer service task to interpret and process a command it
    196           * received on the timer queue.
    197           */
    198          static void	prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
    199          
    200          /*
    201           * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
    202           * depending on if the expire time causes a timer counter overflow.
    203           */
    204          static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
    205          
    206          /*
    207           * An active timer has reached its expire time.  Reload the timer if it is an
    208           * auto reload timer, then call its callback.
    209           */
    210          static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
    211          
    212          /*
    213           * The tick count has overflowed.  Switch the timer lists after ensuring the
    214           * current timer list does not still reference some timers.
    215           */
    216          static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
    217          
    218          /*
    219           * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
    220           * if a tick count overflow occurred since prvSampleTimeNow() was last called.
    221           */
    222          static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
    223          
    224          /*
    225           * If the timer list contains any active timers then return the expire time of
    226           * the timer that will expire first and set *pxListWasEmpty to false.  If the
    227           * timer list does not contain any timers then return 0 and set *pxListWasEmpty
    228           * to pdTRUE.
    229           */
    230          static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
    231          
    232          /*
    233           * If a timer has expired, process it.  Otherwise, block the timer service task
    234           * until either a timer does expire or a command is received.
    235           */
    236          static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
    237          
    238          /*-----------------------------------------------------------*/
    239          
    240          BaseType_t xTimerCreateTimerTask( void )
    241          {
    242          BaseType_t xReturn = pdFAIL;
    243          
    244          	/* This function is called when the scheduler is started if
    245          	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
    246          	timer service task has been created/initialised.  If timers have already
    247          	been created then the initialisation will already have been performed. */
    248          	prvCheckForValidListAndQueue();
    249          
    250          	if( xTimerQueue != NULL )
    251          	{
    252          		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    253          		{
    254          			/* Create the timer task, storing its handle in xTimerTaskHandle so
    255          			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
    256          			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
    257          		}
    258          		#else
    259          		{
    260          			/* Create the timer task without storing its handle. */
    261          			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    262          		}
    263          		#endif
    264          	}
    265          	else
    266          	{
    267          		mtCOVERAGE_TEST_MARKER();
    268          	}
    269          
    270          	configASSERT( xReturn );
    271          	return xReturn;
    272          }
    273          /*-----------------------------------------------------------*/
    274          
    275          TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    276          {
    277          Timer_t *pxNewTimer;
    278          
    279          	/* Allocate the timer structure. */
    280          	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    281          	{
    282          		pxNewTimer = NULL;
    283          	}
    284          	else
    285          	{
    286          		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    287          		if( pxNewTimer != NULL )
    288          		{
    289          			/* Ensure the infrastructure used by the timer service task has been
    290          			created/initialised. */
    291          			prvCheckForValidListAndQueue();
    292          
    293          			/* Initialise the timer structure members using the function parameters. */
    294          			pxNewTimer->pcTimerName = pcTimerName;
    295          			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    296          			pxNewTimer->uxAutoReload = uxAutoReload;
    297          			pxNewTimer->pvTimerID = pvTimerID;
    298          			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    299          			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    300          
    301          			traceTIMER_CREATE( pxNewTimer );
    302          		}
    303          		else
    304          		{
    305          			traceTIMER_CREATE_FAILED();
    306          		}
    307          	}
    308          
    309          	/* 0 is not a valid value for xTimerPeriodInTicks. */
    310          	configASSERT( ( xTimerPeriodInTicks > 0 ) );
    311          
    312          	return ( TimerHandle_t ) pxNewTimer;
    313          }
    314          /*-----------------------------------------------------------*/
    315          
    316          BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
    317          {
    318          BaseType_t xReturn = pdFAIL;
    319          DaemonTaskMessage_t xMessage;
    320          
    321          	/* Send a message to the timer service task to perform a particular action
    322          	on a particular timer definition. */
    323          	if( xTimerQueue != NULL )
    324          	{
    325          		/* Send a command to the timer service task to start the xTimer timer. */
    326          		xMessage.xMessageID = xCommandID;
    327          		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    328          		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    329          
    330          		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    331          		{
    332          			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    333          			{
    334          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    335          			}
    336          			else
    337          			{
    338          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    339          			}
    340          		}
    341          		else
    342          		{
    343          			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    344          		}
    345          
    346          		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
    347          	}
    348          	else
    349          	{
    350          		mtCOVERAGE_TEST_MARKER();
    351          	}
    352          
    353          	return xReturn;
    354          }
    355          /*-----------------------------------------------------------*/
    356          
    357          #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    358          
    359          	TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    360          	{
    361          		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
    362          		started, then xTimerTaskHandle will be NULL. */
    363          		configASSERT( ( xTimerTaskHandle != NULL ) );
    364          		return xTimerTaskHandle;
    365          	}
    366          
    367          #endif
    368          /*-----------------------------------------------------------*/
    369          
    370          const char * pcTimerGetTimerName( TimerHandle_t xTimer )
    371          {
    372          Timer_t *pxTimer = ( Timer_t * ) xTimer;
    373          
    374          	return pxTimer->pcTimerName;
    375          }
    376          /*-----------------------------------------------------------*/
    377          
    378          static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
    379          {
    380          BaseType_t xResult;
    381          Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    382          
    383          	/* Remove the timer from the list of active timers.  A check has already
    384          	been performed to ensure the list is not empty. */
    385          	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    386          	traceTIMER_EXPIRED( pxTimer );
    387          
    388          	/* If the timer is an auto reload timer then calculate the next
    389          	expiry time and re-insert the timer in the list of active timers. */
    390          	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    391          	{
    392          		/* The timer is inserted into a list using a time relative to anything
    393          		other than the current time.  It will therefore be inserted into the
    394          		correct list relative to the time this task thinks it is now. */
    395          		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    396          		{
    397          			/* The timer expired before it was added to the active timer
    398          			list.  Reload it now.  */
    399          			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    400          			configASSERT( xResult );
    401          			( void ) xResult;
    402          		}
    403          		else
    404          		{
    405          			mtCOVERAGE_TEST_MARKER();
    406          		}
    407          	}
    408          	else
    409          	{
    410          		mtCOVERAGE_TEST_MARKER();
    411          	}
    412          
    413          	/* Call the timer callback. */
    414          	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    415          }
    416          /*-----------------------------------------------------------*/
    417          
    418          static void prvTimerTask( void *pvParameters )
    419          {
    420          TickType_t xNextExpireTime;
    421          BaseType_t xListWasEmpty;
    422          
    423          	/* Just to avoid compiler warnings. */
    424          	( void ) pvParameters;
    425          
    426          	for( ;; )
    427          	{
    428          		/* Query the timers list to see if it contains any timers, and if so,
    429          		obtain the time at which the next timer will expire. */
    430          		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    431          
    432          		/* If a timer has expired, process it.  Otherwise, block this task
    433          		until either a timer does expire, or a command is received. */
    434          		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    435          
    436          		/* Empty the command queue. */
    437          		prvProcessReceivedCommands();
    438          	}
    439          }
    440          /*-----------------------------------------------------------*/
    441          
    442          static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
    443          {
    444          TickType_t xTimeNow;
    445          BaseType_t xTimerListsWereSwitched;
    446          
    447          	vTaskSuspendAll();
    448          	{
    449          		/* Obtain the time now to make an assessment as to whether the timer
    450          		has expired or not.  If obtaining the time causes the lists to switch
    451          		then don't process this timer as any timers that remained in the list
    452          		when the lists were switched will have been processed within the
    453          		prvSampleTimeNow() function. */
    454          		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    455          		if( xTimerListsWereSwitched == pdFALSE )
    456          		{
    457          			/* The tick count has not overflowed, has the timer expired? */
    458          			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    459          			{
    460          				( void ) xTaskResumeAll();
    461          				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    462          			}
    463          			else
    464          			{
    465          				/* The tick count has not overflowed, and the next expire
    466          				time has not been reached yet.  This task should therefore
    467          				block to wait for the next expire time or a command to be
    468          				received - whichever comes first.  The following line cannot
    469          				be reached unless xNextExpireTime > xTimeNow, except in the
    470          				case when the current timer list is empty. */
    471          				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    472          
    473          				if( xTaskResumeAll() == pdFALSE )
    474          				{
    475          					/* Yield to wait for either a command to arrive, or the
    476          					block time to expire.  If a command arrived between the
    477          					critical section being exited and this yield then the yield
    478          					will not cause the task to block. */
    479          					portYIELD_WITHIN_API();
    480          				}
    481          				else
    482          				{
    483          					mtCOVERAGE_TEST_MARKER();
    484          				}
    485          			}
    486          		}
    487          		else
    488          		{
    489          			( void ) xTaskResumeAll();
    490          		}
    491          	}
    492          }
    493          /*-----------------------------------------------------------*/
    494          
    495          static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    496          {
    497          TickType_t xNextExpireTime;
    498          
    499          	/* Timers are listed in expiry time order, with the head of the list
    500          	referencing the task that will expire first.  Obtain the time at which
    501          	the timer with the nearest expiry time will expire.  If there are no
    502          	active timers then just set the next expire time to 0.  That will cause
    503          	this task to unblock when the tick count overflows, at which point the
    504          	timer lists will be switched and the next expiry time can be
    505          	re-assessed.  */
    506          	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    507          	if( *pxListWasEmpty == pdFALSE )
    508          	{
    509          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    510          	}
    511          	else
    512          	{
    513          		/* Ensure the task unblocks when the tick count rolls over. */
    514          		xNextExpireTime = ( TickType_t ) 0U;
    515          	}
    516          
    517          	return xNextExpireTime;
    518          }
    519          /*-----------------------------------------------------------*/
    520          
    521          static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    522          {
    523          TickType_t xTimeNow;
    524          PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
    525          
    526          	xTimeNow = xTaskGetTickCount();
    527          
    528          	if( xTimeNow < xLastTime )
    529          	{
    530          		prvSwitchTimerLists();
    531          		*pxTimerListsWereSwitched = pdTRUE;
    532          	}
    533          	else
    534          	{
    535          		*pxTimerListsWereSwitched = pdFALSE;
    536          	}
    537          
    538          	xLastTime = xTimeNow;
    539          
    540          	return xTimeNow;
    541          }
    542          /*-----------------------------------------------------------*/
    543          
    544          static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
    545          {
    546          BaseType_t xProcessTimerNow = pdFALSE;
    547          
    548          	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    549          	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    550          
    551          	if( xNextExpiryTime <= xTimeNow )
    552          	{
    553          		/* Has the expiry time elapsed between the command to start/reset a
    554          		timer was issued, and the time the command was processed? */
    555          		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    556          		{
    557          			/* The time between a command being issued and the command being
    558          			processed actually exceeds the timers period.  */
    559          			xProcessTimerNow = pdTRUE;
    560          		}
    561          		else
    562          		{
    563          			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    564          		}
    565          	}
    566          	else
    567          	{
    568          		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    569          		{
    570          			/* If, since the command was issued, the tick count has overflowed
    571          			but the expiry time has not, then the timer must have already passed
    572          			its expiry time and should be processed immediately. */
    573          			xProcessTimerNow = pdTRUE;
    574          		}
    575          		else
    576          		{
    577          			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    578          		}
    579          	}
    580          
    581          	return xProcessTimerNow;
    582          }
    583          /*-----------------------------------------------------------*/
    584          
    585          static void	prvProcessReceivedCommands( void )
    586          {
    587          DaemonTaskMessage_t xMessage;
    588          Timer_t *pxTimer;
    589          BaseType_t xTimerListsWereSwitched, xResult;
    590          TickType_t xTimeNow;
    591          
    592          	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    593          	{
    594          		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
    595          		{
    596          			/* Negative commands are pended function calls rather than timer
    597          			commands. */
    598          			if( xMessage.xMessageID < ( BaseType_t ) 0 )
    599          			{
    600          				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
    601          
    602          				/* The timer uses the xCallbackParameters member to request a
    603          				callback be executed.  Check the callback is not NULL. */
    604          				configASSERT( pxCallback );
    605          
    606          				/* Call the function. */
    607          				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
    608          			}
    609          			else
    610          			{
    611          				mtCOVERAGE_TEST_MARKER();
    612          			}
    613          		}
    614          		#endif /* INCLUDE_xTimerPendFunctionCall */
    615          
    616          		/* Commands that are positive are timer commands rather than pended
    617          		function calls. */
    618          		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    619          		{
    620          			/* The messages uses the xTimerParameters member to work on a
    621          			software timer. */
    622          			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    623          
    624          			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    625          			{
    626          				/* The timer is in a list, remove it. */
    627          				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    628          			}
    629          			else
    630          			{
    631          				mtCOVERAGE_TEST_MARKER();
    632          			}
    633          
    634          			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
    635          
    636          			/* In this case the xTimerListsWereSwitched parameter is not used, but
    637          			it must be present in the function call.  prvSampleTimeNow() must be
    638          			called after the message is received from xTimerQueue so there is no
    639          			possibility of a higher priority task adding a message to the message
    640          			queue with a time that is ahead of the timer daemon task (because it
    641          			pre-empted the timer daemon task after the xTimeNow value was set). */
    642          			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    643          
    644          			switch( xMessage.xMessageID )
    645          			{
    646          				case tmrCOMMAND_START :
    647          			    case tmrCOMMAND_START_FROM_ISR :
    648          			    case tmrCOMMAND_RESET :
    649          			    case tmrCOMMAND_RESET_FROM_ISR :
    650          				case tmrCOMMAND_START_DONT_TRACE :
    651          					/* Start or restart a timer. */
    652          					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    653          					{
    654          						/* The timer expired before it was added to the active
    655          						timer list.  Process it now. */
    656          						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    657          						traceTIMER_EXPIRED( pxTimer );
    658          
    659          						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    660          						{
    661          							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    662          							configASSERT( xResult );
    663          							( void ) xResult;
    664          						}
    665          						else
    666          						{
    667          							mtCOVERAGE_TEST_MARKER();
    668          						}
    669          					}
    670          					else
    671          					{
    672          						mtCOVERAGE_TEST_MARKER();
    673          					}
    674          					break;
    675          
    676          				case tmrCOMMAND_STOP :
    677          				case tmrCOMMAND_STOP_FROM_ISR :
    678          					/* The timer has already been removed from the active list.
    679          					There is nothing to do here. */
    680          					break;
    681          
    682          				case tmrCOMMAND_CHANGE_PERIOD :
    683          				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
    684          					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    685          					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    686          
    687          					/* The new period does not really have a reference, and can be
    688          					longer or shorter than the old one.  The command time is
    689          					therefore set to the current time, and as the period cannot be
    690          					zero the next expiry time can only be in the future, meaning
    691          					(unlike for the xTimerStart() case above) there is no fail case
    692          					that needs to be handled here. */
    693          					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    694          					break;
    695          
    696          				case tmrCOMMAND_DELETE :
    697          					/* The timer has already been removed from the active list,
    698          					just free up the memory. */
    699          					vPortFree( pxTimer );
    700          					break;
    701          
    702          				default	:
    703          					/* Don't expect to get here. */
    704          					break;
    705          			}
    706          		}
    707          	}
    708          }
    709          /*-----------------------------------------------------------*/
    710          
    711          static void prvSwitchTimerLists( void )
    712          {
    713          TickType_t xNextExpireTime, xReloadTime;
    714          List_t *pxTemp;
    715          Timer_t *pxTimer;
    716          BaseType_t xResult;
    717          
    718          	/* The tick count has overflowed.  The timer lists must be switched.
    719          	If there are any timers still referenced from the current timer list
    720          	then they must have expired and should be processed before the lists
    721          	are switched. */
    722          	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    723          	{
    724          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    725          
    726          		/* Remove the timer from the list. */
    727          		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    728          		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    729          		traceTIMER_EXPIRED( pxTimer );
    730          
    731          		/* Execute its callback, then send a command to restart the timer if
    732          		it is an auto-reload timer.  It cannot be restarted here as the lists
    733          		have not yet been switched. */
    734          		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    735          
    736          		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    737          		{
    738          			/* Calculate the reload value, and if the reload value results in
    739          			the timer going into the same timer list then it has already expired
    740          			and the timer should be re-inserted into the current list so it is
    741          			processed again within this loop.  Otherwise a command should be sent
    742          			to restart the timer to ensure it is only inserted into a list after
    743          			the lists have been swapped. */
    744          			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    745          			if( xReloadTime > xNextExpireTime )
    746          			{
    747          				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    748          				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    749          				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    750          			}
    751          			else
    752          			{
    753          				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    754          				configASSERT( xResult );
    755          				( void ) xResult;
    756          			}
    757          		}
    758          		else
    759          		{
    760          			mtCOVERAGE_TEST_MARKER();
    761          		}
    762          	}
    763          
    764          	pxTemp = pxCurrentTimerList;
    765          	pxCurrentTimerList = pxOverflowTimerList;
    766          	pxOverflowTimerList = pxTemp;
    767          }
    768          /*-----------------------------------------------------------*/
    769          
    770          static void prvCheckForValidListAndQueue( void )
    771          {
    772          	/* Check that the list from which active timers are referenced, and the
    773          	queue used to communicate with the timer service, have been
    774          	initialised. */
    775          	taskENTER_CRITICAL();
    776          	{
    777          		if( xTimerQueue == NULL )
    778          		{
    779          			vListInitialise( &xActiveTimerList1 );
    780          			vListInitialise( &xActiveTimerList2 );
    781          			pxCurrentTimerList = &xActiveTimerList1;
    782          			pxOverflowTimerList = &xActiveTimerList2;
    783          			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    784          			configASSERT( xTimerQueue );
    785          
    786          			#if ( configQUEUE_REGISTRY_SIZE > 0 )
    787          			{
    788          				if( xTimerQueue != NULL )
    789          				{
    790          					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    791          				}
    792          				else
    793          				{
    794          					mtCOVERAGE_TEST_MARKER();
    795          				}
    796          			}
    797          			#endif /* configQUEUE_REGISTRY_SIZE */
    798          		}
    799          		else
    800          		{
    801          			mtCOVERAGE_TEST_MARKER();
    802          		}
    803          	}
    804          	taskEXIT_CRITICAL();
    805          }
    806          /*-----------------------------------------------------------*/
    807          
    808          BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    809          {
    810          BaseType_t xTimerIsInActiveList;
    811          Timer_t *pxTimer = ( Timer_t * ) xTimer;
    812          
    813          	/* Is the timer in the list of active timers? */
    814          	taskENTER_CRITICAL();
    815          	{
    816          		/* Checking to see if it is in the NULL list in effect checks to see if
    817          		it is referenced from either the current or the overflow timer lists in
    818          		one go, but the logic has to be reversed, hence the '!'. */
    819          		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
    820          	}
    821          	taskEXIT_CRITICAL();
    822          
    823          	return xTimerIsInActiveList;
    824          } /*lint !e818 Can't be pointer to const due to the typedef. */
    825          /*-----------------------------------------------------------*/
    826          
    827          void *pvTimerGetTimerID( const TimerHandle_t xTimer )
    828          {
    829          Timer_t * const pxTimer = ( Timer_t * ) xTimer;
    830          
    831          	return pxTimer->pvTimerID;
    832          }
    833          /*-----------------------------------------------------------*/
    834          
    835          #if( INCLUDE_xTimerPendFunctionCall == 1 )
    836          
    837          	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
    838          	{
    839          	DaemonTaskMessage_t xMessage;
    840          	BaseType_t xReturn;
    841          
    842          		/* Complete the message with the function parameters and post it to the
    843          		daemon task. */
    844          		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    845          		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    846          		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    847          		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    848          
    849          		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    850          
    851          		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
    852          
    853          		return xReturn;
    854          	}
    855          
    856          #endif /* INCLUDE_xTimerPendFunctionCall */
    857          /*-----------------------------------------------------------*/
    858          
    859          #if( INCLUDE_xTimerPendFunctionCall == 1 )
    860          
    861          	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
    862          	{
    863          	DaemonTaskMessage_t xMessage;
    864          	BaseType_t xReturn;
    865          
    866          		/* This function can only be called after a timer has been created or
    867          		after the scheduler has been started because, until then, the timer
    868          		queue does not exist. */
    869          		configASSERT( xTimerQueue );
    870          
    871          		/* Complete the message with the function parameters and post it to the
    872          		daemon task. */
    873          		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
    874          		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    875          		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    876          		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    877          
    878          		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    879          
    880          		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
    881          
    882          		return xReturn;
    883          	}
    884          
    885          #endif /* INCLUDE_xTimerPendFunctionCall */
    886          /*-----------------------------------------------------------*/
    887          
    888          /* This entire source file will be skipped if the application is not configured
    889          to include software timer functionality.  If you want to include software timer
    890          functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
    891          #endif /* configUSE_TIMERS == 1 */
    892          
    893          
    894          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   pcTimerGetTimerName
       8   prvCheckForValidListAndQueue
         8   -> platform_assert
         8   -> vListInitialise
         8   -> vPortEnterCritical
         0   -> vPortExitCritical
         8   -> vQueueAddToRegistry
         8   -> xQueueGenericCreate
       0   prvGetNextExpireTime
       8   prvInsertTimerInActiveList
         8   -> vListInsert
      24   prvProcessExpiredTimer
         0   -- Indirect call
        24   -> platform_assert
        24   -> prvInsertTimerInActiveList
        24   -> uxListRemove
        24   -> xTimerGenericCommand
      32   prvProcessReceivedCommands
        32   -- Indirect call
        32   -> platform_assert
        32   -> prvInsertTimerInActiveList
        32   -> prvSampleTimeNow
        32   -> uxListRemove
        32   -> vPortFree
        32   -> xQueueGenericReceive
        32   -> xTimerGenericCommand
      24   prvProcessTimerOrBlockTask
        24   -> prvProcessExpiredTimer
        24   -> prvSampleTimeNow
        24   -> vQueueWaitForMessageRestricted
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
      16   prvSampleTimeNow
        16   -> prvSwitchTimerLists
        16   -> xTaskGetTickCount
      24   prvSwitchTimerLists
        24   -- Indirect call
        24   -> platform_assert
        24   -> uxListRemove
        24   -> vListInsert
        24   -> xTimerGenericCommand
       8   prvTimerTask
         8   -> prvGetNextExpireTime
         8   -> prvProcessReceivedCommands
         8   -> prvProcessTimerOrBlockTask
       0   pvTimerGetTimerID
      32   xTimerCreate
        32   -> platform_assert
        32   -> prvCheckForValidListAndQueue
        32   -> pvPortMalloc
        32   -> vListInitialiseItem
      24   xTimerCreateTimerTask
        24   -> platform_assert
        24   -> prvCheckForValidListAndQueue
        24   -> xTaskGenericCreate
      32   xTimerGenericCommand
        32   -> xQueueGenericSend
        32   -> xQueueGenericSendFromISR
        32   -> xTaskGetSchedulerState
       8   xTimerIsTimerActive
         8   -> vPortEnterCritical
         8   -> vPortExitCritical


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       8  ?_0
       8  ?_1
      72  ?_2
      28  ?_3
       8  ?_4
      40  ?_5
      12  ?_6
       8  ?_7
       4  pcTimerGetTimerName
      96  prvCheckForValidListAndQueue
      26  prvGetNextExpireTime
      62  prvInsertTimerInActiveList
      92  prvProcessExpiredTimer
     202  prvProcessReceivedCommands
      92  prvProcessTimerOrBlockTask
      38  prvSampleTimeNow
     106  prvSwitchTimerLists
      20  prvTimerTask
       4  pvTimerGetTimerID
      52  pxCurrentTimerList
          pxOverflowTimerList
          xTimerQueue
          xActiveTimerList1
          xActiveTimerList2
       4  xLastTime
      84  xTimerCreate
      76  xTimerCreateTimerTask
      76  xTimerGenericCommand
      28  xTimerIsTimerActive

 
    56 bytes in section .bss
 1 202 bytes in section .text
 
 1 202 bytes of CODE memory
    56 bytes of DATA memory

Errors: none
Warnings: none
